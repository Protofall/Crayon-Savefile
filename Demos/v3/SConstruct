program_name = 'Crayon-Savefile-Demo-v3'
ip_bin_path = ''

# ------------- FUNCTION 1 BEGIN ------------- #

# Get arguments in the format we want
PLATFORM = ARGUMENTS.get('PLATFORM')
DEBUG = ARGUMENTS.get('DEBUG', '0').lower()	# If var not present, default to False
if DEBUG == 'true' or DEBUG == '1':
	DEBUG = True
if DEBUG == 'false' or DEBUG == '0':
	DEBUG = False

# Check if arguments are valid
supported_platforms = ['dreamcast', 'pc', 'all']
if PLATFORM == None or PLATFORM not in supported_platforms or (DEBUG != False and DEBUG != True):
	print("""
	Please specify the target platform to compile this project for. You can also
	optionally enable debug flags. By default debug is false.

	eg. `scons PLATFORM=dreamcast DEBUG=false`.
	""")
	print('\tSupported platforms are:')
	for p in supported_platforms:
		print('\t- ' + p)

	exit(1)

# ------------- FUNCTION 1 END ------------- #

# ------------- FUNCTION 2 BEGIN ------------- #

# Create the environments
# The #/ means relative to the calling script, so even in
# SConscript it works from this file rather than relative
lib_folder = '#/../../libCrayonSavefile/'
include_path = lib_folder + 'include/'

import os
env = list()
if PLATFORM == 'dreamcast' or PLATFORM == 'all':
	env.append(Environment(ENV = os.environ, CPPPATH = include_path, CC = 'kos-cc', CXX = 'kos-c++', AR = 'kos-ar'))

	# Making sure we use the right prefix and suffix
	env[-1]['LIBPREFIX'] = 'lib'
	env[-1]['LIBSUFFIX'] = '.a'
	env[-1]['OBJSUFFIX'] = '.o'	# Windows has .obj
	env[-1]['PROGSUFFIX'] = '.elf'

	# Fix this later, here's a hack for now
	env[-1]['KOS_BASE'] = env[-1]['ENV']['KOS_BASE']
	env[-1]['KOS_GENROMFS'] = env[-1]['ENV']['KOS_GENROMFS']

	# Location of IP.BIN
	env[-1]['IP_DIR'] = ip_bin_path + 'IP.BIN'

	# Add the platform
	env[-1]['PLATFORM'] = 'dreamcast'
	env[-1]['SPECIFIC_PLATFORM'] = env[-1]['PLATFORM']

from sys import platform
if PLATFORM == 'pc' or PLATFORM == 'all':
	env.append(Environment(ENV = os.environ, CPPPATH = include_path))	#Apparently some ppl need that ENV for CCVERSION

	# Add the platform
	env[-1]['PLATFORM'] = 'pc'
	if platform.startswith('linux') == True:
		env[-1]['SPECIFIC_PLATFORM'] = 'linux'
	elif platform == 'win32':
		env[-1]['SPECIFIC_PLATFORM'] = 'windows'
	elif platform == 'darwin':
		env[-1]['SPECIFIC_PLATFORM'] = 'mac'
	else:
		print('Platform "' + platform + '" is not supported')
		exit(1)

colour_version = [4, 9, 0]

# Set some env vars for all envs
for e in env:
	e['CODE_DIR'] = 'code'
	e['CDFS_DIR'] = 'cdfs'
	e['PROG_NAME'] = program_name

	#Add in some cflags if in debug mode
	if DEBUG == True:
		e.AppendUnique(CPPFLAGS = ['-g3', '-Wall', '-Wformat=2', '-fno-common'])

	# Enables GCC colour (Since it normally only does colour for terminals and scons is just an "output")
	# Major, Minor, Patch version numbers
	# We need the CC and CXX checks for pc because this flag is only for GCC/G++
	our_version = list(map(int, e['CCVERSION'].split('.')))
	if all([a >= b for a, b in zip(our_version, colour_version)]) and
		(e['PLATFORM'] != 'pc' or (e['CC'] == 'gcc' or e['CXX'] == 'g++')):
		e.AppendUnique(CCFLAGS = ['-fdiagnostics-color=always'])

# ------------- FUNCTION 2 END ------------- #

lib_dict = SConscript(lib_folder + 'SConstruct')

import sys
for e in env:
	try:
		lib = lib_dict[e['SPECIFIC_PLATFORM']]
	except KeyError:
		print('Somehow lib file for "' + specific_platform +'" cannot be found', file = sys.stderr)
		exit(1)

	lib_path = lib_folder + 'lib/' + e['SPECIFIC_PLATFORM'] +'/'

	e['BUILD_DIR'] = 'build/' + e['SPECIFIC_PLATFORM']
	e['PROG_DIR'] = 'program/' + e['SPECIFIC_PLATFORM']
	
	# !!! NOTE !!!: If you are looking at this SConstruct file to "learn how to use it" or "see a good
	# example", this part right here is NOT the best practice. What you should actually do is have an
	# SConscript file in code/ and call it with variant_dir parameter set to $BUILD_DIR. Then that
	# script contains the code below this VariantDir call. The way its currently setup can be confusing
	# and error-prone. The reasons I'm not doing that here is because I want everything in one file and
	# people might be confused why an SConscript file is in their code folder, so this way people can
	# just see this SConstruct file and know "That's the build file".
	e.VariantDir('$BUILD_DIR', '$CODE_DIR', duplicate=0)	# Kind of moves over the processing for the code
															# directory to our build dir duplicate=0 means it
															# won't duplicate the src files

	src_files = e.Glob('$BUILD_DIR/*.c') # We have to specify the build path instead of the real one
	if e['PLATFORM'] == 'pc':
		e.Program('$PROG_DIR/$PROG_NAME', src_files, LIBS = lib, LIBPATH = lib_path)
	elif e['PLATFORM'] == 'dreamcast':
		rom_img = e.Command('$BUILD_DIR/romdisk_boot.img', 'romdisk_boot/',
			'$KOS_GENROMFS -f $TARGET -d $SOURCE')
		src_files.append(e.Command('$BUILD_DIR/romdisk_boot.o', rom_img,
			'$KOS_BASE/utils/bin2o/bin2o $SOURCE romdisk_boot $TARGET'))

		# The source files list can contain c files and objects
		elf = e.Program('$BUILD_DIR/${PROG_NAME}', src_files, LIBS = lib, LIBPATH = lib_path)
		# e.Install(prog_dir, elf)	#Some people want the elf instead
		binary = e.Command('$BUILD_DIR/${PROG_NAME}.bin', elf,
			'sh-elf-objcopy -R .stack -O binary $SOURCE $TARGET')
		scrambled = e.Command('$CDFS_DIR/1ST_READ.BIN', binary,
			'$KOS_BASE/utils/scramble/scramble $SOURCE $TARGET')
		# Iso depends on cdfs_scrambled, but we pass in "cdfs/"" instead of the source/s
		iso = e.Command('$BUILD_DIR/${PROG_NAME}.iso', scrambled,
			'genisoimage -G $IP_DIR -C 0,11702 -J -l -r -o $TARGET $CDFS_DIR')
		cdi = e.Command('$PROG_DIR/${PROG_NAME}.cdi', iso,
			'cdi4dc $SOURCE $TARGET')

# Import our helper functions
import builder_functions as bf

ARGUMENTS = bf.input_handling(ARGUMENTS)	#Process our arguments
env = bf.create_builders(ARGUMENTS, paths, program_name)

# Create our library/s
lib_dict = dict()
for e, p in zip(env, bf.get_supported_platforms()):	#zip stops at the shorter of the two lists
	#Add in some cflags if in debug mode
	if ARGUMENTS['DEBUG'] == True:
		e.AppendUnique(CPPDEFINES = [{'CRAYON_DEBUG':1}])
		# These can be helpful sometimes
		# e.AppendUnique(CPPFLAGS = ['-Wconversion', '-Wno-unused-parameter'])
		# conversion will check for type conversions (eg uint8_t var = (U32 VAR))
		# no-unused-parameter disables said check

	build_dir = 'build/' + p + '/'
	e.VariantDir(build_dir, 'code', duplicate=0)	# Kind of moves over the processing for the code
													# directory to our build dir duplicate=0 means it
													# won't duplicate the src files

	prog_files = Glob(build_dir + '*.c') # We have to specify the build path instead of the real one
	lib_dict[p] = e.Library(target = 'lib/' + p + '/' + 'CrayonSavefile', source = prog_files)

Return('lib_dict')

//LIB SCONSTRUCT FILE FUNCTIONALITY
    //must take platform from args
        //dc, pc or "all" for both
            //I have no idea if "all" is possible. If I set a PC and DC flags and have if statements for both,
            //it should work
    //have an option to compile in debug mode
        //This adds compile parameters -DCRAYON_DEBUG=1 and -g
        //Do this by modifying the environment
    //When building Dreamcast, don't forget to set the compiler flags, change the gcc compiler and the "ar" thing

    //I need to control *where* it outputs the lib file. I also need to tell it where the .h files are too
    //-c should require the user to specify a platform to clean aswell




# ar

#    Sets construction variables for the ar library archiver.

#    Sets: $AR, $ARCOM, $ARFLAGS, $LIBPREFIX, $LIBSUFFIX, $RANLIB, $RANLIBCOM, $RANLIBFLAGS.








//CHECK BELOW NOTES



// New system plan

// (IMPLEMENTED)
// - The add functions return an int ID. We add all variables that ever existed
//     - static uint32_t id = 0; then id++ at the end of the function to get the new id values
// - The add function also has a field for the version removed. Set to 0 if still present
// - The remove function will be deleted since its functionality is useless
// - Those remove handling defines will be deleted


// (UNIMPLEMENTED)
// - So now when a variable is deleted and we want to handle how its value influences the new savefile system, the user defined function handles that
//     - I'm not 100% sure how it will work yet, but it will use the IDs returned by the add function to reference different variables throughout the history of the savefile. The user would also have if statements with version ids to control when we change a variable and how.
//     - The parameters will probable be two crayon_savefile_data_t pointers and the two version numbers (One struct is of current version and other is of an older version)

// - void *crayon_savefile_get_var(uint32_t id, crayon_savefile_data_t *data, crayon_savefile_history_t *history, crayon_savefile_version_t version);
//     - Could be used to get a pointer to the right block of memory. However it would be slow since they need to traverse the whole history linked list. Maybe in the solidify stage the linked list is converted into an array so its as simple as using the id to get the right history node. But even then, how do we know where the value is in data?

// ALTERNATIVE APPROACH
// - A function that returns an array of unions such that element X contains a pointer to the block of memory for variable with id X. The function would need the history list, target version and savedata. This does mean the user will need to be aware of what kind of pointer they use since they're handling a union which is a bit strange to most people.
//     - crayon_savefile_variable_ptr_t *crayon_savefile_get_variable_pointers(crayon_savefile_data_t *data, crayon_savefile_history_t *history, crayon_savefile_version_t version);
//     - They would only need to call this for the old savefile since they can just use their own var pointers for the new savedata (The one thats a part of details)
//     - Maybe the union array should be made before the user function is called and its passed in by reference instead of crayon_savefile_data_t *loaded_data? Also we don't really need to pass in crayon_savefile_data_t *latest_data either if our variables are global (Which they should be). So parameters is just the union array and version numbers
//     - Maybe the array contains as many elements as all-time variables, but vars not in the current version are set to zero 

// What purpose does the history list have?
//     - Construct a crayon_savefile_data_t struct for any savefile version
//     - Locate where where any variable of id X would be in that crayon_savefile_data_t struct











// COMMAND
// make clean-pc && make pc && cp pc_savefile_backups/v0-Modified/SAVE_DEMO3.s saves/















//Notes:

//I don't think the pointers the user has are mapped to the variables right


#include <stdio.h>

int hidden[10]; //The actual values we manipulate
int ** mapper;  //The variable in the history struct
int * visible;  //This is what the user controls

void func(void ** lol){
    mapper = (int**)lol;
}

#define USE_FUNCTION

int main()
{
    #ifdef USE_FUNCTION
    func(&visible);    //Doesn't set it right
    #else
    mapper = &visible;
    #endif
    *mapper = &hidden[4];
    
    for(int i= 0; i < 10; i++){
        hidden[i] = 500 + i;
    }
    
    printf("%d", visible[0]);

    return 0;
}


